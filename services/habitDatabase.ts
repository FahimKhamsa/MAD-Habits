import { supabase } from '@/lib/supabase';
import { Habit, HabitCompletion } from '@/types';

export interface DatabaseHabit {
  id: string; // This is the primary key generated by the database
  user_id: string;
  name: string;
  description: string | null;
  frequency: 'daily' | 'weekly' | 'monthly';
  days_of_week: number[] | null;
  icon: string | null; // Added icon field
  color: string | null; // Added color field
  streak: number;
  best_streak: number;
  created_at: string;
  updated_at: string;
}

export interface DatabaseHabitCompletion {
  id: string;
  habit_id: string;
  user_id: string;
  date: string;
  completed: boolean;
  note: string | null;
  created_at: string;
  updated_at: string;
}

// Convert database habit to app habit format
const convertDbHabitToAppHabit = (
  dbHabit: DatabaseHabit
): Habit => {
  return {
    id: dbHabit.id, // Use dbHabit.id as the primary identifier
    name: dbHabit.name,
    description: dbHabit.description || '',
    frequency: dbHabit.frequency,
    daysOfWeek: dbHabit.days_of_week || undefined,
    icon: dbHabit.icon || 'ðŸŽ¯', // Default icon if null
    color: dbHabit.color || '#3B82F6', // Default color if null
    streak: dbHabit.streak,
    bestStreak: dbHabit.best_streak,
    completedDates: [], // Will be populated separately
    createdAt: dbHabit.created_at,
    updatedAt: dbHabit.updated_at,
  };
};

// Convert database completion to app completion format
const convertDbCompletionToAppCompletion = (
  dbCompletion: DatabaseHabitCompletion
): HabitCompletion => {
  return {
    id: dbCompletion.id,
    habitId: dbCompletion.habit_id,
    date: dbCompletion.date,
    completed: dbCompletion.completed,
    note: dbCompletion.note || undefined,
  };
};

// Convert app habit to database format
const convertAppHabitToDbHabit = (
  habit: Partial<Habit>,
  userId: string
): Partial<DatabaseHabit> => {
  return {
    user_id: userId,
    name: habit.name,
    description: habit.description || null,
    frequency: habit.frequency,
    days_of_week: habit.daysOfWeek || null,
    icon: habit.icon || null, // Include icon
    color: habit.color || null, // Include color
    streak: habit.streak || 0,
    best_streak: habit.bestStreak || 0,
  };
};

export class HabitDatabaseService {
  // Get current user
  private async getCurrentUser() {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error || !user) {
      throw new Error('User not authenticated');
    }
    return user;
  }

  // Fetch all habits and their completions for current user
  async fetchHabitsAndCompletions(): Promise<{ habits: Habit[]; completions: HabitCompletion[] }> {
    try {
      const user = await this.getCurrentUser();

      const { data: habitsData, error: habitsError } = await supabase
        .from('habits')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (habitsError) throw habitsError;

      const appHabits = habitsData?.map(convertDbHabitToAppHabit) || [];

      // Fetch all completions for the user
      const { data: completionsData, error: completionsError } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('user_id', user.id);

      if (completionsError) throw completionsError;

      const appCompletions = completionsData?.map(convertDbCompletionToAppCompletion) || [];

      // Update completedDates for each habit based on fetched completions
      const habitsWithCompletions = appHabits.map(habit => {
        const habitCompletedDates = appCompletions
          .filter(c => c.habitId === habit.id && c.completed)
          .map(c => c.date.split('T')[0]);
        return { ...habit, completedDates: habitCompletedDates };
      });

      return { habits: habitsWithCompletions, completions: appCompletions };

    } catch (error) {
      console.error('Error fetching habits and completions:', error);
      throw error;
    }
  }

  // Create a new habit
  async createHabit(habitData: Omit<Habit, 'id' | 'streak' | 'bestStreak' | 'completedDates' | 'createdAt' | 'updatedAt'>): Promise<Habit> {
    try {
      const user = await this.getCurrentUser();
      
      const dbHabit = convertAppHabitToDbHabit(habitData, user.id);

      const { data, error } = await supabase
        .from('habits')
        .insert([dbHabit])
        .select()
        .single();

      if (error) throw error;

      return convertDbHabitToAppHabit(data);
    } catch (error) {
      console.error('Error creating habit:', error);
      throw error;
    }
  }

  // Update an existing habit
  async updateHabit(habitId: string, updates: Partial<Habit>): Promise<Habit> {
    try {
      const user = await this.getCurrentUser();
      
      const dbUpdates = convertAppHabitToDbHabit(updates, user.id);
      delete dbUpdates.user_id; // Don't update the user_id

      const { data, error } = await supabase
        .from('habits')
        .update({
          ...dbUpdates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', habitId) // Change to 'id'
        .eq('user_id', user.id)
        .select()
        .single();

      if (error) throw error;

      // Fetch completions for updated habit
      const { data: completionsData } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('habit_id', habitId);

      const appCompletions = completionsData?.map(convertDbCompletionToAppCompletion) || [];
      const habitCompletedDates = appCompletions
        .filter(c => c.habitId === data.id && c.completed)
        .map(c => c.date.split('T')[0]);

      return { ...convertDbHabitToAppHabit(data), completedDates: habitCompletedDates };
    } catch (error) {
      console.error('Error updating habit:', error);
      throw error;
    }
  }

  // Delete a habit
  async deleteHabit(habitId: string): Promise<void> {
    try {
      const user = await this.getCurrentUser();

      // First delete all completions for this habit
      const { error: completionsError } = await supabase
        .from('habit_completions')
        .delete()
        .eq('habit_id', habitId)
        .eq('user_id', user.id);

      if (completionsError) throw completionsError;

      // Then delete the habit
      const { error: habitError } = await supabase
        .from('habits')
        .delete()
        .eq('id', habitId) // Change to 'id'
        .eq('user_id', user.id);

      if (habitError) throw habitError;
    } catch (error) {
      console.error('Error deleting habit:', error);
      throw error;
    }
  }

  // Toggle habit completion
  async toggleHabitCompletion(habitId: string, date: string, note?: string): Promise<{ habit: Habit; completion: HabitCompletion }> {
    try {
      const user = await this.getCurrentUser();
      const dateStr = date.split('T')[0];

      // Check if completion already exists
      const { data: existingCompletion } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('habit_id', habitId)
        .eq('user_id', user.id)
        .eq('date', dateStr)
        .single();

      let completionData;

      if (existingCompletion) {
        // Toggle existing completion
        const { data, error } = await supabase
          .from('habit_completions')
          .update({
            completed: !existingCompletion.completed,
            note: note || existingCompletion.note,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCompletion.id)
          .select()
          .single();

        if (error) throw error;
        completionData = data;
      } else {
        // Create new completion
        const { data, error } = await supabase
          .from('habit_completions')
          .insert([{
            habit_id: habitId,
            user_id: user.id,
            date: dateStr,
            completed: true,
            note: note || null,
          }])
          .select()
          .single();

        if (error) throw error;
        completionData = data;
      }

      // Fetch all completions for this habit to recalculate streak
      const { data: allCompletions } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('habit_id', habitId)
        .eq('user_id', user.id)
        .eq('completed', true)
        .order('date', { ascending: false });

      // Calculate streak
      const completedDates = (allCompletions || []).map(c => c.date);
      const { currentStreak, bestStreak } = this.calculateStreak(completedDates);

      // Update habit with new streak info
      const { data: updatedHabit, error: habitError } = await supabase
        .from('habits')
        .update({
          streak: currentStreak,
          best_streak: bestStreak,
          updated_at: new Date().toISOString(),
        })
        .eq('id', habitId) // Change to 'id'
        .eq('user_id', user.id)
        .select()
        .single();

      if (habitError) throw habitError;

      // Fetch all completions again for the updated habit
      const { data: finalCompletionsData } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('habit_id', habitId);

      const appCompletions = finalCompletionsData?.map(convertDbCompletionToAppCompletion) || [];
      const habitCompletedDates = appCompletions
        .filter(c => c.habitId === updatedHabit.id && c.completed)
        .map(c => c.date.split('T')[0]);

      const habit = { ...convertDbHabitToAppHabit(updatedHabit), completedDates: habitCompletedDates };
      
      const completion: HabitCompletion = convertDbCompletionToAppCompletion(completionData);

      return { habit, completion };
    } catch (error) {
      console.error('Error toggling habit completion:', error);
      throw error;
    }
  }

  // Calculate streak from completed dates
  private calculateStreak(completedDates: string[]): { currentStreak: number; bestStreak: number } {
    if (completedDates.length === 0) {
      return { currentStreak: 0, bestStreak: 0 };
    }

    const sortedDates = completedDates.sort((a, b) => new Date(b).getTime() - new Date(a).getTime());
    const today = new Date().toISOString().split('T')[0];
    
    let currentStreak = 0;
    let bestStreak = 0;
    let tempStreak = 0;

    // Calculate current streak
    if (sortedDates[0] === today || sortedDates[0] === this.getYesterday()) {
      currentStreak = 1;
      
      for (let i = 1; i < sortedDates.length; i++) {
        const currentDate = new Date(sortedDates[i - 1]);
        const nextDate = new Date(sortedDates[i]);
        const daysDifference = Math.floor((currentDate.getTime() - nextDate.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysDifference === 1) {
          currentStreak++;
        } else {
          break;
        }
      }
    }

    // Calculate best streak
    tempStreak = 1;
    for (let i = 1; i < sortedDates.length; i++) {
      const currentDate = new Date(sortedDates[i - 1]);
      const nextDate = new Date(sortedDates[i]);
      const daysDifference = Math.floor((currentDate.getTime() - nextDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysDifference === 1) {
        tempStreak++;
      } else {
        bestStreak = Math.max(bestStreak, tempStreak);
        tempStreak = 1;
      }
    }
    bestStreak = Math.max(bestStreak, tempStreak, currentStreak);

    return { currentStreak, bestStreak };
  }

  private getYesterday(): string {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    return yesterday.toISOString().split('T')[0];
  }

  // Fetch completions for a specific date
  async fetchCompletionsForDate(date: string): Promise<HabitCompletion[]> {
    try {
      const user = await this.getCurrentUser();
      const dateStr = date.split('T')[0];

      const { data, error } = await supabase
        .from('habit_completions')
        .select('*')
        .eq('user_id', user.id)
        .eq('date', dateStr);

      if (error) throw error;

      return (data || []).map(completion => ({
        id: completion.id,
        habitId: completion.habit_id,
        date: completion.date,
        completed: completion.completed,
        note: completion.note || undefined,
      }));
    } catch (error) {
      console.error('Error fetching completions for date:', error);
      throw error;
    }
  }
}

export const habitDb = new HabitDatabaseService();
